## 개요

샤딩(Sharding)은 대규모 데이터베이스 환경에서 데이터를 여러 물리적 서버에 분산하여 저장하는 수평 분할 기법이다. 이는 데이터베이스의 확장성과 성능을 향상시키는 데 효과적이지만, 특정 SQL 작업에서는 비효율이 발생할 수 있다. 특히 멀티 벨류 인서트(Multi-value INSERT)는 샤딩 환경에서 심각한 성능 저하를 일으킬 수 있다. 이 문서에서는 샤딩 구조에서 멀티 벨류 인서트가 왜 비효율적인지 기술적으로 설명하고, 대안을 제시한다.

## 샤딩 구조의 이해

### 샤딩이란?

샤딩은 대용량 데이터를 여러 데이터베이스 서버(샤드)에 분산하여 저장하는 기술이다. 각 샤드는 전체 데이터의 일부분만 담당하며, 이를 통해 단일 서버의 부하를 분산시킨다.

### 샤딩 키(Sharding Key)

데이터가 어떤 샤드에 저장될지 결정하는 기준이 되는 컬럼이다. 일반적으로 다음과 같은 방식으로 데이터를 분산한다:

1. **해시 기반 샤딩**: 샤딩 키의 해시값을 계산하여 특정 샤드에 할당
   ```
   shard_id = hash(sharding_key) % number_of_shards
   ```

2. **범위 기반 샤딩**: 샤딩 키의 값 범위에 따라 샤드 할당
   ```
   if sharding_key between 1 and 1000: shard_1
   if sharding_key between 1001 and 2000: shard_2
   ...
   ```

3. **디렉토리 기반 샤딩**: 샤딩 키와 샤드 간의 매핑 테이블을 유지하여 할당

## 멀티 벨류 인서트(Multi-value INSERT)

### 멀티 벨류 인서트란?

멀티 벨류 인서트는 하나의 SQL 문으로 여러 행을 동시에 삽입하는 기능이다.

```sql
INSERT INTO users (id, name, email) VALUES 
(1, 'User1', 'user1@example.com'),
(2, 'User2', 'user2@example.com'),
(3, 'User3', 'user3@example.com');
```

이 방식은 단일 데이터베이스 환경에서는 매우 효율적이며, 다음과 같은 장점이 있다:
- 네트워크 왕복 시간(Round-trip time) 감소
- 트랜잭션 오버헤드 감소
- 배치 처리를 통한 성능 향상

## 샤딩 환경에서 멀티 벨류 인서트의 비효율성

### 1. 라우팅 오버헤드

샤딩 환경에서 멀티 벨류 인서트의 가장 큰 문제점은 서로 다른 샤드에 데이터를 저장해야 할 때 발생한다.

```sql
-- 샤딩 키가 id인 경우
INSERT INTO users (id, name, email) VALUES 
(1, 'User1', 'user1@example.com'),  -- shard_1에 저장
(2, 'User2', 'user2@example.com'),  -- shard_2에 저장
(3, 'User3', 'user3@example.com');  -- shard_3에 저장
```

이 경우 데이터베이스 미들웨어나 ORM은 다음과 같은 작업을 수행해야 한다:

1. 각 레코드의 샤딩 키를 분석
2. 각 레코드가 어떤 샤드에 저장될지 계산
3. 단일 쿼리를 여러 샤드별 쿼리로 분할
4. 각 샤드에 개별적으로 쿼리 실행

이 과정에서 상당한 오버헤드가 발생하며, 단일 인서트 쿼리를 여러 개로 분할해야 하므로 멀티 벨류 인서트의 장점이 사라진다.

### 2. 트랜잭션 관리의 복잡성

여러 샤드에 걸친 트랜잭션은 분산 트랜잭션(Distributed Transaction)을 필요로 하며, 이는 다음과 같은 문제를 야기한다:

- **2단계 커밋(Two-Phase Commit)**: 모든 샤드가 준비되었는지 확인한 후 커밋하는 과정이 필요
- **부분 실패 가능성**: 일부 샤드에서만 실패할 경우 데이터 일관성 문제 발생
- **성능 저하**: 분산 트랜잭션은 단일 데이터베이스 트랜잭션보다 훨씬 느림

```
-- 분산 트랜잭션 의사 코드
BEGIN TRANSACTION
  TRY
    INSERT INTO shard_1.users VALUES (1, 'User1', 'user1@example.com')
    INSERT INTO shard_2.users VALUES (2, 'User2', 'user2@example.com')
    INSERT INTO shard_3.users VALUES (3, 'User3', 'user3@example.com')
    COMMIT
  CATCH
    ROLLBACK
  END TRY
```

### 3. 벌크 최적화 불가

단일 데이터베이스에서는 벌크 인서트에 대한 다양한 최적화가 적용되지만, 샤딩 환경에서는 이러한 최적화가 제한된다:

- 로그 최적화 제한
- 인덱스 업데이트 최적화 제한
- 데이터베이스 엔진별 벌크 인서트 최적화 기능 활용 불가

### 4. 성능 측정 예시

| 인서트 방식 | 단일 DB 성능 | 샤딩 DB 성능 | 성능 차이 |
|------------|------------|------------|----------|
| 개별 인서트 | 1000 TPS   | 900 TPS    | -10%     |
| 멀티 벨류 인서트(10개) | 5000 TPS | 1200 TPS | -76% |
| 멀티 벨류 인서트(100개) | 20000 TPS | 1500 TPS | -92.5% |

*TPS: Transactions Per Second (초당 트랜잭션 수)

위 표에서 볼 수 있듯이, 단일 데이터베이스에서는 멀티 벨류 인서트가 성능을 크게 향상시키지만, 샤딩 환경에서는 그 효과가 크게 감소한다. 특히 한 번에 삽입하는 레코드 수가 많을수록 샤딩 환경에서의 성능 저하가 더 심각해진다.

## 샤딩 환경에서의 효율적인 대안

### 1. 샤드별 배치 처리

같은 샤드에 저장될 데이터를 그룹화하여 샤드별로 멀티 벨류 인서트를 실행한다.

```
# 의사 코드 (Pseudocode)
recordsByShardId = {}  # 샤드 ID를 키로 하는 맵 생성

# 레코드를 샤드별로 그룹화
for each record in records:
    shardId = calculateShardId(record.shardingKey)
    if shardId not in recordsByShardId:
        recordsByShardId[shardId] = []
    recordsByShardId[shardId].append(record)

# 샤드별로 멀티 벨류 인서트 실행
for shardId, shardRecords in recordsByShardId.items():
    executeMultiValueInsert(shardId, shardRecords)
```

### 2. 비동기 처리

각 샤드에 대한 인서트 작업을 비동기적으로 처리하여 병렬성을 높인다.

```
# 의사 코드 (Pseudocode)
futures = []  # 비동기 작업을 저장할 리스트

# 각 샤드에 대해 비동기 작업 생성
for shardId, shardRecords in recordsByShardId.items():
    # 비동기 작업 생성 및 시작
    future = createAsyncTask(function() {
        executeMultiValueInsert(shardId, shardRecords)
    })
    
    # 생성된 작업을 리스트에 추가
    futures.append(future)

# 모든 비동기 작업 완료 대기
waitForAllTasks(futures)
```

### 3. 샤딩 키 설계 최적화

가능하다면, 관련 데이터가 같은 샤드에 저장되도록 샤딩 키를 설계한다.

- **관련 엔티티 함께 저장**: 부모-자식 관계의 데이터는 같은 샤드에 저장
- **데이터 지역성 고려**: 자주 함께 접근하는 데이터는 같은 샤드에 배치

### 4. 벌크 로드 유틸리티 사용

대량 데이터 적재 시에는 데이터베이스 벤더에서 제공하는 벌크 로드 유틸리티를 사용한다.

- MySQL: `LOAD DATA INFILE`
- PostgreSQL: `COPY`
- MongoDB: `mongoimport`

이러한 유틸리티는 일반적인 INSERT 문보다 훨씬 효율적으로 대량 데이터를 적재할 수 있다.

## 결론

샤딩 구조의 데이터베이스에서 멀티 벨류 인서트는 다음과 같은 이유로 비효율적이다:

1. 서로 다른 샤드로의 라우팅 오버헤드
2. 분산 트랜잭션 관리의 복잡성
3. 데이터베이스 엔진의 벌크 최적화 기능 활용 제한

이러한 문제를 해결하기 위해서는:

- 샤드별로 데이터를 그룹화하여 배치 처리
- 비동기 병렬 처리 활용
- 샤딩 키 설계 최적화
- 대량 데이터 적재 시 전용 유틸리티 사용

샤딩 환경에서 효율적인 데이터 삽입을 위해서는 애플리케이션 레벨에서의 최적화가 필수적이며, 단순히 데이터베이스 기능에만 의존해서는 최적의 성능을 얻기 어렵다.