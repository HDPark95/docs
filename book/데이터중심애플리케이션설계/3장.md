# 3장 저장소와 검색

## 저장소 엔진 개요

데이터베이스가 데이터를 저장하고 검색하는 방법은 성능에 결정적인 영향을 미친다. 데이터베이스는 본질적으로 두 가지 기본 작업을 수행한다: 데이터를 저장(쓰기)하고, 저장된 데이터를 다시 찾아내는(읽기) 것이다. 이 장에서는 이러한 작업을 효율적으로 수행하기 위한 다양한 저장소 엔진의 내부 구조를 살펴본다.

### 저장소 엔진의 두 가지 계열

**1. 로그 구조(Log-Structured) 계열**
- 연속된 추가 전용(append-only) 레코드로 구성
- 순차적 쓰기로 높은 쓰기 처리량 달성
- 주기적인 컴팩션과 병합이 필요
- 예: LSM 트리, HBase, Cassandra, LevelDB, RocksDB

**2. 페이지 지향(Page-Oriented) 계열**
- 고정 크기 페이지 단위로 데이터 관리
- 제자리 갱신(in-place update) 지원
- B-트리가 대표적인 예
- 예: 대부분의 관계형 데이터베이스 (PostgreSQL, MySQL, Oracle)

### 색인의 중요성

색인(Index)은 특정 키의 값을 효율적으로 찾기 위한 추가적인 데이터 구조다. 색인을 유지하면 쓰기 속도가 느려지는 오버헤드가 발생하지만, 읽기 성능을 크게 향상시킬 수 있다. 이는 저장소 시스템 설계의 핵심 트레이드오프다.

> "색인은 쓰기 성능을 희생하여 읽기 성능을 향상시킨다. 모든 색인은 데이터베이스에 쓰기를 더 느리게 만든다."

---

## 해시 색인 (Hash Indexes)

### 키-값 저장소의 가장 단순한 색인

해시 색인은 인메모리 해시맵을 사용하여 각 키를 디스크의 바이트 오프셋에 매핑한다.

**동작 원리**
```
메모리 해시맵: { "user:123" → 오프셋 42768 }
디스크 파일: [오프셋 42768]에 실제 데이터 저장
```

**장점**
- 매우 빠른 읽기 성능 (한 번의 디스크 탐색)
- 간단한 구현
- 고정된 키 집합에 효율적

**단점**
- 모든 키가 메모리에 있어야 함
- 범위 질의 불가능
- 해시 충돌 처리 필요

### 세그먼트와 컴팩션

**세그먼트 파일 관리**
- 로그를 특정 크기의 세그먼트로 분할
- 세그먼트가 가득 차면 새 세그먼트 파일 생성
- 백그라운드에서 오래된 세그먼트 컴팩션 수행

**컴팩션 과정**
1. 중복된 키 제거 (최신 값만 유지)
2. 삭제된 키 제거 (톰스톤 처리)
3. 작은 세그먼트들을 병합하여 큰 세그먼트 생성
4. 병합된 세그먼트로 원자적 전환

**실제 구현 시 고려사항**
- **파일 형식**: 바이너리 형식 사용으로 공간 효율성 향상
- **삭제 처리**: 특별한 삭제 레코드(톰스톤) 추가
- **충돌 복구**: 체크섬으로 손상된 세그먼트 감지
- **동시성 제어**: 하나의 쓰기 스레드, 여러 읽기 스레드

---

## SS테이블과 LSM 트리

### SS테이블 (Sorted String Table)

SS테이블은 세그먼트 파일의 형식을 개선한 것으로, **키로 정렬된** 키-값 쌍의 시퀀스다.

**SS테이블의 장점**
1. **효율적인 병합**: 여러 세그먼트를 병합정렬 알고리즘으로 효율적으로 병합
2. **희소 색인**: 모든 키를 메모리에 유지할 필요 없음
3. **압축 가능**: 블록 단위로 압축하여 디스크 I/O 감소

**희소 색인 동작 예시**
```
메모리 색인:
handbag → 오프셋 0
handsome → 오프셋 10240
happy → 오프셋 20480

"handiwork" 검색 시:
→ handbag과 handsome 사이 스캔
```

### LSM 트리 구조

**LSM(Log-Structured Merge) 트리의 동작**

1. **쓰기 경로**:
   - 쓰기가 인메모리 균형 트리(멤테이블)에 추가됨
   - 멤테이블이 임계값에 도달하면 SS테이블로 플러시
   - 새로운 쓰기는 새 멤테이블 인스턴스에 계속

2. **읽기 경로**:
   - 먼저 멤테이블 확인
   - 그 다음 가장 최신 세그먼트부터 오래된 순서로 확인
   - 백그라운드에서 세그먼트 병합 및 컴팩션 수행

### 성능 최적화

**블룸 필터 (Bloom Filter)**
- 키가 존재하지 않는다는 것을 빠르게 판단
- 확률적 자료구조로 false positive는 가능하지만 false negative는 불가능
- LSM 트리의 읽기 성능을 크게 향상

**컴팩션 전략**

**1. 크기 계층(Size-Tiered) 컴팩션**
- 비슷한 크기의 새롭고 작은 SS테이블을 병합
- HBase, Cassandra 초기 버전에서 사용
- 공간 증폭이 발생할 수 있음

**2. 레벨(Leveled) 컴팩션**
- 키 범위를 더 작은 SS테이블로 분할
- 오래된 데이터를 별도 "레벨"로 이동
- LevelDB, RocksDB, Cassandra에서 사용
- 더 적은 공간 오버헤드

### LSM 트리의 특징

**장점**
- 매우 높은 쓰기 처리량 (순차적 쓰기)
- 효율적인 공간 사용 (컴팩션으로 인한 압축)
- 범위 질의 지원

**단점**
- 컴팩션으로 인한 I/O 대역폭 사용
- 쓰기 증폭 (Write Amplification)
- 예측 불가능한 성능 (컴팩션 타이밍)

---

## B 트리

### B 트리의 구조

B 트리는 1970년에 도입되어 현재까지 가장 널리 사용되는 색인 구조다. LSM 트리와 달리 B 트리는 고정 크기 블록이나 페이지(보통 4KB)로 나누어 관리한다.

**B 트리의 특징**
- 균형 트리 구조 유지
- 각 페이지는 여러 자식 페이지에 대한 참조 포함
- 리프 페이지에 실제 값이나 값에 대한 참조 저장
- 분기 계수(branching factor)는 보통 수백 개

**B 트리 구조 예시**
```
           [100, 200]              (루트)
          /     |     \
    [50, 75]  [150]  [250, 300]   (중간 노드)
       |        |        |
   [값들...]  [값들...]  [값들...]   (리프 노드)
```

### B 트리 갱신 알고리즘

**키 추가/갱신 과정**
1. 키를 포함하는 리프 페이지 찾기
2. 페이지에 공간이 있으면 갱신/추가
3. 공간이 없으면 페이지 분할:
   - 페이지를 반으로 나눔
   - 부모 페이지 갱신
   - 필요시 부모 페이지도 분할 (재귀적)

### 신뢰할 수 있는 B 트리 만들기

**쓰기 전 로그(Write-Ahead Log, WAL)**
- 트리 페이지를 변경하기 전에 로그에 먼저 기록
- 충돌 후 일관된 상태로 복구 가능
- 리두 로그(redo log)라고도 불림

**동시성 제어**
- 래치(latch)를 사용한 트리 데이터 구조 보호
- 읽기는 여러 스레드가 동시에 가능
- 쓰기는 배타적 접근 필요

**최적화 기법**
1. **쓰기 시 복사(Copy-on-Write)**: 수정된 페이지를 다른 위치에 쓰기
2. **키 약어 사용**: 페이지에 더 많은 키 저장
3. **형제 페이지 포인터**: 순차 스캔 최적화
4. **프랙탈 트리**: 캐시 효율적인 변형

---

## B 트리와 LSM 트리 비교

### 쓰기 증폭 (Write Amplification)

**쓰기 증폭의 정의**
- 데이터베이스에 한 번 쓰기가 디스크에 여러 번 쓰기를 유발하는 현상

**LSM 트리의 쓰기 증폭**
- 컴팩션과 병합으로 인한 반복적인 쓰기
- SSD의 수명에 직접적인 영향

**B 트리의 쓰기 증폭**
- 페이지 단위 쓰기 (작은 변경도 전체 페이지 쓰기)
- WAL 로그 추가 쓰기

### 성능 특성 비교

**LSM 트리의 장점**
- 높은 쓰기 처리량 (순차적 쓰기)
- 더 나은 압축 (중복 제거)
- 낮은 저장 공간 오버헤드

**B 트리의 장점**
- 예측 가능한 성능
- 각 키가 색인에 정확히 한 곳에만 존재
- 트랜잭션 지원이 더 쉬움

