# 10장 HTTP/2.0

## HTTP/2.0 개요

HTTP/2.0은 웹 성능 개선을 위해 개발된 HTTP/1.1의 후속 프로토콜이다. Google의 SPDY 프로토콜을 기반으로 하며, 기존 HTTP/1.1의 의미론(semantics)을 유지하면서 전송 효율성을 크게 향상시켰다.

### HTTP/2.0 등장 배경
- HTTP/1.1의 병렬 연결과 파이프라이닝은 근본적인 성능 문제를 해결하지 못함
- 웹 페이지의 복잡도 증가로 더 효율적인 프로토콜 필요
- 모바일 환경에서의 성능 최적화 요구 증가

### SPDY 프로토콜
- 2009년 Google이 개발한 실험적 프로토콜
- HTTP/2.0의 기초가 됨
- 주요 목표:
  - 헤더 압축을 통한 대역폭 절감
  - 단일 TCP 연결로 여러 요청 처리
  - 페이지 로드 시간 단축

---

## HTTP/2.0의 주요 특징

### 1. 바이너리 프레이밍 (Binary Framing)

**프레임 구조**
- 모든 메시지는 바이너리 프레임으로 전송
- 8바이트 헤더 + 최대 16,383 바이트 페이로드
- TCP 연결 위에서 동작

**프레임 타입**
- DATA: 응답 본문 전송
- HEADERS: 헤더 정보 전송
- PRIORITY: 스트림 우선순위 설정
- RST_STREAM: 스트림 종료
- SETTINGS: 연결 설정
- PUSH_PROMISE: 서버 푸시 예고
- PING: 연결 상태 확인
- GOAWAY: 연결 종료 예고
- WINDOW_UPDATE: 흐름 제어 윈도우 업데이트
- CONTINUATION: 헤더 블록 연속

### 2. 멀티플렉싱 (Multiplexing)

**동시 다중 스트림**
- 하나의 TCP 연결에서 여러 스트림을 동시에 처리
- 각 스트림은 독립적으로 처리되어 블로킹 없음
- Head-of-Line(HOL) 블로킹 문제 해결

**HTTP/1.1과의 차이점**
```
HTTP/1.1: 요청1 → 응답1 → 요청2 → 응답2 (순차적)
HTTP/2.0: 요청1, 요청2, 요청3 → 응답2, 응답1, 응답3 (동시 다발적)
```

**장점**
- 연결 설정 오버헤드 감소
- 네트워크 자원 효율적 사용
- 더 빠른 페이지 로딩

### 3. 헤더 압축 (Header Compression)

**HPACK 압축 알고리즘**
- 헤더 필드를 압축하여 전송
- 정적 테이블과 동적 테이블 사용
- 중복된 헤더 제거

**압축 과정**
1. 압축 컨텍스트 생성
2. 헤더를 조각(fragment)으로 분할
3. 각 조각을 압축하여 전송
4. 수신측에서 조각 재조립 및 압축 해제

**효과**
- 헤더 크기 85-88% 감소
- 특히 쿠키가 많은 요청에서 효과적
- 모바일 환경에서 대역폭 절약

### 4. 서버 푸시 (Server Push)

**능동적 리소스 전송**
- 클라이언트 요청 없이 서버가 리소스를 미리 전송
- HTML 문서와 함께 CSS, JavaScript 등을 푸시
- 왕복 시간(RTT) 감소

**동작 방식**
1. 클라이언트가 HTML 요청
2. 서버가 HTML 응답과 함께 관련 리소스 푸시 예고(PUSH_PROMISE)
3. 클라이언트 캐시 확인 후 수락/거부 결정
4. 서버가 푸시 스트림으로 리소스 전송

**사용 예시**
```
클라이언트: GET /index.html
서버: index.html 전송
서버: PUSH_PROMISE /style.css
서버: PUSH_PROMISE /script.js
서버: style.css, script.js 자동 전송
```

### 5. 스트림 우선순위 (Stream Prioritization)

**우선순위 설정**
- 각 스트림에 가중치(1-256) 할당
- 의존성 트리 구성 가능
- 중요한 리소스 먼저 전송

**우선순위 메커니즘**
- 의존성: 특정 스트림이 다른 스트림에 의존
- 가중치: 동일 레벨 스트림 간 리소스 배분 비율
- 동적 조정: 실행 중 우선순위 변경 가능

**주의사항**
- 우선순위는 힌트일 뿐, 보장되지 않음
- 서버 구현에 따라 처리 방식 다름

---

## 연결 관리

### 연결 수명
- HTTP/2.0은 장기 연결(long-lived connection) 지향
- 하나의 연결을 재사용하여 오버헤드 최소화
- 연결 유지를 위한 PING 프레임 사용

### 흐름 제어
- 스트림 레벨과 연결 레벨 흐름 제어
- WINDOW_UPDATE 프레임으로 수신 가능 데이터량 통보
- 수신자 과부하 방지

### 연결 종료
- GOAWAY 프레임으로 정상 종료 알림
- 진행 중인 스트림 완료 후 종료
- 에러 발생 시 RST_STREAM으로 개별 스트림 종료

---

## HTTP/1.1과의 호환성

### 의미론 유지
- 메서드, 상태 코드, 헤더 필드 동일
- URI 체계 그대로 사용
- 쿠키, 인증, 캐싱 메커니즘 호환

### 프로토콜 협상
**ALPN (Application-Layer Protocol Negotiation)**
- TLS 핸드셰이크 중 프로토콜 협상
- 클라이언트가 지원 프로토콜 목록 제시
- 서버가 선택하여 응답

**HTTP Upgrade**
- 평문 연결에서 HTTP/2.0으로 업그레이드
- Upgrade 헤더 사용
```http
GET / HTTP/1.1
Host: example.com
Connection: Upgrade, HTTP2-Settings
Upgrade: h2c
HTTP2-Settings: <base64url 인코딩된 설정>
```

### 프록시 및 중개자 처리
- HTTP/1.1 프록시는 HTTP/2.0 트래픽을 HTTP/1.1로 변환
- 투명 프록시는 바이너리 프레임 처리 불가
- HTTP/2.0 지원 프록시 필요

---

## 보안 고려사항

### 중개자 캡슐화 공격
- HTTP/1.1과 HTTP/2.0 간 변환 시 발생 가능
- 헤더 필드 검증 강화 필요
- 프록시의 적절한 변환 로직 구현 중요

### 장기 연결의 프라이버시 위험
- 오래 유지되는 연결로 사용자 추적 가능성
- 연결 재사용으로 인한 정보 노출 위험
- 적절한 연결 수명 관리 필요

### TLS 사용 권장
- HTTP/2.0은 TLS 사용을 강력히 권장
- 많은 브라우저는 TLS 없이 HTTP/2.0 지원 안 함
- 보안과 성능 동시 확보

---

## 성능 개선 효과

### 측정 가능한 개선사항
- 페이지 로드 시간 15-60% 단축
- 네트워크 대역폭 사용량 감소
- 서버 연결 수 감소로 리소스 절약

### 실제 환경에서의 이점
**저지연 환경**
- 멀티플렉싱으로 여러 요청 동시 처리
- 서버 푸시로 왕복 시간 절감

**고지연 환경(모바일)**
- 연결 재사용으로 핸드셰이크 오버헤드 감소
- 헤더 압축으로 데이터 전송량 절감

**리소스가 많은 페이지**
- 우선순위 지정으로 중요 리소스 먼저 로드
- 동시 전송으로 전체 로딩 시간 단축

---

## HTTP/2.0 구현 시 고려사항

### 서버 설정
- 적절한 동시 스트림 수 설정
- 헤더 테이블 크기 조정
- 푸시 전략 수립

### 클라이언트 최적화
- HTTP/2.0 지원 여부 확인
- 폴백 메커니즘 구현
- 푸시된 리소스 캐시 관리

### 모니터링 및 디버깅
- 프레임 레벨 분석 도구 필요
- 스트림 상태 추적
- 성능 메트릭 수집

### 마이그레이션 전략
1. 현재 성능 기준선 측정
2. HTTP/2.0 지원 인프라 준비
3. 단계적 적용 및 A/B 테스트
4. 성능 모니터링 및 최적화
5. 전체 적용 및 HTTP/1.1 폴백 유지