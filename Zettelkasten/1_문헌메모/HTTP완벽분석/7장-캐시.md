7장 캐시

웹 캐시란 무엇인가

• 웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치다.

• 웹 요청이 캐시에 도착했을 때, 캐시된 로컬 사본이 존재한다면, 그 문서는 원 서버가 아니라 그 캐시로부터 제공된다.

⸻

캐시가 주는 혜택

• 캐시는 불필요한 데이터 전송을 줄여서, 네트워크 요금으로 인한 비용을 줄여 준다.

• 캐시는 네트워크 병목을 줄여준다. 대역폭을 늘리지 않고도 페이지를 빨리 불러올 수 있게 된다.

• 캐시는 원 서버에 대한 요청을 줄여준다. 서버는 부하를 줄일 수 있으며 더 빨리 응답할 수 있게 된다.

• 페이지를 먼 곳에서 불러올수록 시간이 많이 걸리는데, 캐시는 거리로 인한 지연을 줄여준다.

⸻

중복된 트래픽

• 똑같은 문서를 네트워크를 통해 계속 가져오는 것은 값비싼 네트워크 대역폭을 낭비하고, 전송을 느리게 하며, 웹 서버에 부하를 준다.

• 캐시를 이용하면, 첫 번째 서버 응답은 캐시에 보관된다. 뒤이은 요청들에 대한 응답으로는 캐시된 사본이 사용될 수 있다.

⸻

대역폭 병목

• 캐시는 네트워크 병목을 줄여준다. 많은 네트워크가 원격 서버보다는 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공한다.

• 클라이언트들이 서버에 접근할 때의 속도는, 그 경로에 있는 가장 느린 네트워크의 속도와 같다.

• 만약 클라이언트가 빠른 LAN에 있는 캐시로부터 사본을 가져온다면, 캐싱은 성능을 대폭 개선할 수 있다.

⸻

갑작스런 요청 쇄도(Flash Crowds)

• 캐싱은 갑작스런 요청 쇄도에 대처하기 위해 특히 중요하다.

• 갑작스런 사건(유명인사와 관련된 뉴스, 정전, 지진 등)으로 인해 많은 사람이 거의 동시에 웹 문서에 접근할 때 발생한다.

• 이 갑작스런 요청 쇄도는 네트워크와 웹 서버의 심각한 장애를 일으킬 수 있다.

⸻

거리로 인한 지연

• 모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킨다.

• 클라이언트와 서버 사이에 라우터가 많지 않더라도, 빛의 속도 그 자체가 상당한 지연을 유발한다.

⸻

적중과 부적중

• 캐시 적중(cache hit): 캐시에 요청이 도착했을 때, 대응하는 사본이 있다면 이를 이용해 요청이 처리되는 것

• 캐시 부적중(cache miss): 대응하는 사본이 없다면 원 서버로 전달되는 것

⸻

재검사(Revalidation)

• 원 서버 콘텐츠는 변경될 수 있기 때문에, 캐시는 반드시 그들이 갖고 있는 사본이 최신인지 서버를 통해 때때로 점검해야 한다.

• 이러한 신선도 검사를 HTTP 재검사라 부른다.

• 캐시는 클라이언트가 사본을 요청했을 때 충분히 오래된 경우에만 재검사를 진행한다.

• 캐시가 재검사 요청을 보냈을 때, 서버가 콘텐츠가 변경되지 않았다면 서버는 작은 304 Not Modified 응답을 보낸다.

⸻

재검사 적중과 재검사 부적중

• 재검사 적중 (또는 느린 적중): 서버 객체가 변경되지 않았다면 서버는 304 Not Modified 응답을 클라이언트에게 보낸다. 이는 캐시 적중보다는 느리지만 캐시 부적중보다는 빠르다.

• 재검사 부적중: 서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 200 OK 응답을 클라이언트에게 보낸다.

• 객체 삭제: 서버 객체가 삭제되었다면, 서버는 404 Not Found 응답을 보내며, 캐시는 사본을 삭제한다.

⸻

적중률

• 캐시 적중률(캐시 적중비)은 캐시가 요청을 처리하는 비율을 나타낸다.

• 적중률 0%는 모든 요청이 캐시 부적중임을 의미한다.

• 적중률 100%는 모든 요청이 캐시 적중임을 의미한다.

• 오늘날 적중률 40%면 웹 캐시로는 괜찮은 편이다.

⸻

바이트 적중률

• 바이트 적중률은 캐시를 통해 제공된 모든 바이트의 비율을 나타낸다.

• 바이트 단위 적중률은 트래픽이 절감된 정도를 나타낸다.

⸻

적중과 부적중의 구별

• HTTP는 클라이언트에게 응답이 캐시 적중이었는지 아니면 원 서버 접근인지 말해줄 수 있는 방법을 제공하지 않는다.

• 클라이언트가 응답이 캐시에서 왔는지 알아내는 한 가지 방법은 Date 헤더를 이용하는 것이다.

⸻

캐시 토폴로지

• 개인 전용 캐시: 한 명의 사용자에게만 할당된 캐시. 개인 전용 캐시는 보통 웹브라우저에 내장되어 있다.

• 공용 프락시 캐시: 여러 사용자들 간에 공유된 캐시

• 프락시 캐시 계층들: 작은 캐시에서 캐시 부적중이 발생했을 때 더 큰 부모 캐시가 그 "자식"의 프락시 캐시를 대신해서 서비스하는 형태

⸻

캐시 처리 단계

1. 요청 받기: 캐시는 네트워크로부터 도착한 요청 메시지를 읽는다.

2. 파싱: 캐시는 메시지를 파싱하여 URL과 헤더들을 추출한다.

3. 검색: 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아온다(그리고 로컬에 저장한다).

4. 신선도 검사: 캐시는 캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에게 물어본다.

5. 응답 생성: 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다.

6. 발송: 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려준다.

7. 로깅: 선택적으로, 캐시는 로그파일에 트랜잭션을 기술한 로그 하나를 남긴다.

⸻

사본을 신선하게 유지하기

• 캐시된 데이터는 서버의 데이터와 일치하도록 관리되어야 한다.

• HTTP는 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라도, 캐시된 사본이 서버와 충분히 일치하도록 유지할 수 있게 해주는 단순한 메커니즘을 갖고 있다.

⸻

문서 만료

• HTTP는 Cache-Control과 Expires라는 특별한 헤더들을 이용해서 원 서버가 각 문서에 만료 날짜를 붙일 수 있게 해준다.

• 캐시 문서가 만료되면, 캐시는 반드시 서버와 문서에 변경된 것이 있는지 검사해야 한다.

⸻

유효기간과 나이

• 서버는 응답에 HTTP/1.0+ Expires나 HTTP/1.1 Cache-Control: max-age 응답 헤더를 이용해서 유효기간을 명시한다.

• Expires 헤더는 절대 날짜를 명시한다. 

• Cache-Control: max-age 헤더는 문서의 최대 나이를 정의한다. (예: Cache-Control: max-age=123456)

⸻

서버 재검사

• 캐시된 문서가 만료되었다는 것은 그 문서가 원 서버에 현재 존재하는 것과 다르다는 것을 의미하지는 않는다.

• 캐시는 문서가 변경되었는지 검사하기 위해 원 서버에게 작은 재검사 요청을 보낸다.

⸻

조건부 메서드와 재검사

• HTTP의 조건부 메서드는 재검사를 효율적으로 만든다.

• HTTP는 캐시된 객체를 재확인하기 위해 몇 가지 도구를 제공하며, 가장 많이 사용되는 것은 If-Modified-Since 헤더다.

• 서버에게 보내는 GET 요청에 If-Modified-Since 헤더를 추가하면, 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미가 된다.

⸻

If-Modified-Since: Date 재검사

• If-Modified-Since 헤더를 GET 요청과 함께 보내면 다음 세 가지 상황 중 하나가 발생한다:

1. 재검사 적중: 서버 객체가 변경되지 않았다면, 서버는 304 Not Modified 응답을 보낸다.

2. 재검사 부적중: 서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 200 OK 응답을 보낸다.

3. 객체 삭제: 서버 객체가 삭제되었다면, 서버는 404 Not Found 응답을 보내며 캐시는 사본을 삭제한다.

⸻

If-None-Match: 엔터티 태그 재검사

• 엔터티 태그는 문서에 대한 일련번호와 같이 동작한다.

• If-None-Match 헤더는 태그 값으로 캐시의 유효성을 판단한다.

• 태그 값을 사용하여 캐시의 유효성을 판단하기 때문에 다음과 같은 경우에 대해 If-Modified-Since보다 유용하다:

  - 어떤 문서는 일정 시간 간격으로 다시 쓰여지지만(예: 백그라운드 프로세스에 의해) 실제로는 같은 데이터를 포함하고 있다.
  
  - 어떤 문서의 변화가 그다지 중요하지 않아서 전 세계의 캐시들이 그것을 다시 읽어들이기엔 부족한 경우
  
  - 어떤 서버들이 그들이 갖고 있는 페이지의 최종 변경일을 정확하게 판별할 수 없는 경우
  
  - 1초보다 작은 간격으로 갱신되는 문서를 제공하는 서버의 경우

⸻

언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가

• HTTP/1.1 클라이언트는 서버가 엔터티 태그를 반환했다면 반드시 엔터티 태그 검사기를 사용해야 한다.

• 서버가 Last-Modified 값만 반환했다면, 클라이언트는 If-Modified-Since 검사를 사용할 수 있다.

• HTTP/1.0과 HTTP/1.1 캐시가 응답을 모두 이해할 수 있도록 원 서버는 가능하면 엔터티 태그와 Last-Modified를 함께 보내야 한다.

⸻

캐시 제어

• HTTP는 문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인지 서버가 설정할 수 있는 여러 가지 방법을 정의한다.

• 캐시 제어 우선순위:

1. Cache-Control: no-store 헤더를 응답에 첨부할 수 있다.
2. Cache-Control: no-cache 헤더를 응답에 첨부할 수 있다.
3. Cache-Control: must-revalidate 헤더를 응답에 첨부할 수 있다.
4. Cache-Control: max-age 헤더를 응답에 첨부할 수 있다.
5. Expires 날짜 헤더를 응답에 첨부할 수 있다.
6. 아무 만료 정보도 주지 않고, 캐시가 스스로 휴리스틱(heuristic) 방법으로 결정하게 한다.

⸻

no-cache와 no-store 응답 헤더

• Cache-Control: no-store

  - no-store가 표시된 응답은 캐시가 그 응답의 사본을 만드는 것을 금지한다.
  
  - 캐시는 보통, 캐시가 아닌 프락시 서버가 하는 것처럼, 클라이언트에게 no-store 응답을 전달하고 객체를 삭제한다.

• Cache-Control: no-cache

  - no-cache로 표시된 응답은 사실 로컬 캐시 저장소에 저장될 수 있다.
  
  - 다만, 먼저 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없을 뿐이다.

⸻

Max-Age 응답 헤더

• Cache-Control: max-age 헤더는 신선도를 나타낸다.

• max-age 값은 문서가 서버로부터 온 이후 흐른 시간이고, 초로 나타낸다.

• 서버는 최대 나이가 0인 경우, 캐시가 매 접근마다 문서를 캐시하거나 리프레시하지 않도록 요청할 수 있다.

⸻

Expires 응답 헤더

• 더 이상 사용하지 않기를 권하는(deprecated) Expires 헤더는 실제 만료 날짜를 명시한다.

• HTTP를 설계한 사람들은 많은 서버가 동기화되지 않거나 부정확한 시계를 갖고 있기 때문에 만료를 절대시각 대신 경과된 시간으로 표현하는 것이 낫다고 판단했다.

⸻

Must-Revalidate 응답 헤더

• 캐시는 성능을 개선하기 위해 신선하지 않은(stale) 객체를 제공하도록 설정될 수 있다.

• Cache-Control: must-revalidate 응답 헤더는 캐시가 이 객체의 신선하지 않은 사본을 원 서버와의 최초 재검사 없이는 제공해서는 안 됨을 의미한다.

⸻

휴리스틱 만료

• 만약 응답이 Cache-Control: max-age 헤더나 Expires 헤더 중 어느 것도 포함하지 않고 있다면, 캐시는 경험적인(heuristic) 방법으로 최대 나이를 계산할 것이다.

• 계산 결과 얻은 최대 나이 값이 24시간보다 크다면, Heuristic Expiration 경고(Warning) 헤더가 응답 헤더에 추가되어야 한다.

⸻

클라이언트 신선도 제약

• 웹브라우저는 브라우저나 프락시 캐시의 신선하지 않은 콘텐츠를 강제로 갱신시켜 주는 리프레시나 리로드 버튼을 갖고 있다.

• 리프레시 버튼은 Cache-Control: max-age=0 요청 헤더가 추가된 GET 요청을 발생시켜서, 중간 캐시들이 그들이 갖고 있는 사본을 서버와 재검사하도록 한다.

⸻

캐시 제어 설정

• 웹 서버들은 캐시 제어와 만료 HTTP 헤더들을 설정하는 서로 다른 메커니즘을 제공한다.

• 아파치 웹서버는 각각의 HTTP 헤더를 설정할 수 있는 여러 가지 메커니즘을 제공한다.

⸻